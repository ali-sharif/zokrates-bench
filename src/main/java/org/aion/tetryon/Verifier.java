// This file is MIT Licensed
package org.aion.tetryon;

import avm.Blockchain;
import org.aion.avm.tooling.abi.Callable;

import java.math.BigInteger;
import java.util.Arrays;

/**
 * Verifier smart contract. Auto-generated by Zokrates.
 */
@SuppressWarnings({"WeakerAccess", "unused"})
public class Verifier {
    protected static class VerifyingKey {
        public final G1Point alpha;
        public final G2Point beta;
        public final G2Point gamma;
        public final G2Point delta;
        public final G1Point[] gamma_abc;

        public VerifyingKey(G1Point alpha, G2Point beta, G2Point gamma, G2Point delta, G1Point[] gamma_abc) {
            this.alpha = alpha;
            this.beta = beta;
            this.gamma = gamma;
            this.delta = delta;
            this.gamma_abc = gamma_abc;
        }
    }

    protected static class Proof {
        public final G1Point a;
        public final G2Point b;
        public final G1Point c;

        public Proof(G1Point a, G2Point b, G1Point c) {
            this.a = a;
            this.b = b;
            this.c = c;
        }

        // serialized as a | b | c
        public byte[] serialize() {
            byte[] s = new byte[Fp.ELEMENT_SIZE*8];

            byte[] a = G1.serialize(this.a);
            byte[] b = G2.serialize(this.b);
            byte[] c = G1.serialize(this.c);

            System.arraycopy(a, 0, s, 0, a.length);
            System.arraycopy(b, 0, s, 6*Fp.ELEMENT_SIZE - b.length, b.length);
            System.arraycopy(c, 0, s, 8*Fp.ELEMENT_SIZE - c.length, c.length);

            return s;
        }

        public static Proof deserialize(byte[] data) {
            Blockchain.require(data.length == 8*Fp.ELEMENT_SIZE);

            G1Point a = G1.deserialize(Arrays.copyOfRange(data, 0, 2*Fp.ELEMENT_SIZE));
            G2Point b = G2.deserialize(Arrays.copyOfRange(data, 2*Fp.ELEMENT_SIZE, 6*Fp.ELEMENT_SIZE));
            G1Point c = G1.deserialize(Arrays.copyOfRange(data, 6*Fp.ELEMENT_SIZE, 8*Fp.ELEMENT_SIZE));

            return new Proof(a, b, c);
        }
    }

    protected static VerifyingKey verifyingKey() {
        G1Point alpha = new G1Point("01547529271a00eaf749789330629eb1a2aa2bb0691db18f98569772de954a2f", "0f8ae429d12d4e5e333ad7031feb226f79f85a6677c15c45fcde66bea86f685f");
        G2Point beta = new G2Point("2a5ddc34c7788247b152d9f6b01661d16384e53b676d3b96354b1ec40b56f56d", "0e54b09d7ec2c87099db915a83adc5016f8b3a4b0e9350feb4d9be8cd397065e", "23bfd1c3310e76eda49a8a3f47d34273644a78fd206ed982a78922283ca2d9cb", "1d68c87e42499f1088c988ef58ab70aa8e8bc878bc915e84a2bf04d3718824c8");
        G2Point gamma = new G2Point("1545f702fdd1e2f26cde710f08d68d45a9f51de289ab1f4facb56e26b8094dea", "010030835d4b3299add584e54552213a37638cf6bffa478796c12e6b2190eaba", "26e56a63b2a991826f343d6aac1424ca1b7474fbe43daad27945a81fd0ae1860", "1f1320cfd11a7c9ff2e8c36c49688a169679709ee23cf0d1902a7804e1c5050c");
        G2Point delta = new G2Point("292afd1bc2a1aebb9ff9c85bd59c9993c258f89b2e56eb34d22719bd047a28bf", "2e55b4b7f9098aae210d8157eaaae03723f99ef7d2f1dd5100c384552d670b68", "02624645c544088bc9d730944ceddc2bc662c2c28860a857a2d72f4a9e4b8670", "005dc2063c9e3d1e45d1d6d26ec88b092c8d03ffaedc61d31b1779c0d700fc4a");

        G1Point[] gamma_abc = new G1Point[3];
        gamma_abc[0] = new G1Point("0c0252111c0de9298e623b339c89958ddbb540b73bb1a9d5451dbe40291f128e", "2d1aa8415e72e896a8b5a863fc12bafb6948bead6a013a97389bfa0477d2c7de");
        gamma_abc[1] = new G1Point("0548ae50b34e4c50cdfd98f5d3710a9bca0b5d61b78ddaad4548d07d10875c2f", "237f6cdac56979fba82e7a6beaf604c2f067bea54bfc3876ab95669cfdba89ed");
        gamma_abc[2] = new G1Point("081347b6d70f5e86a90efd64e26d290e6a156ece5cadc2b930f49bef44af33ff", "0e8dfbc24243a53a20448f98b4d3b8d1a819464634f03c4f6d46050cf2e1a0b3");

        return new VerifyingKey(alpha, beta, gamma, delta, gamma_abc);
    }

    public static boolean verify(BigInteger[] input, Proof proof) throws Exception {
        BigInteger snarkScalarField = new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617");
        VerifyingKey vk = verifyingKey();
        Blockchain.require(input.length + 1 == vk.gamma_abc.length);

        // X = gamma_0 + gamma_1 * input_0 + gamma_2 * input_1
        G1Point X = new G1Point(Fp.zero(), Fp.zero());
        for (int i = 0; i < input.length; i++) {
            Blockchain.require(input[i].compareTo(snarkScalarField) < 0);
            G1Point tmp = G1.mul(vk.gamma_abc[i + 1], input[i]);
            if (i == 0)
                X = tmp;
            else
                X = G1.add(X, tmp);
        }
        X = G1.add(X, vk.gamma_abc[0]);

        // See [Groth16]
        // [A]_1 * [B]_2 = [alpha]_1 * [beta]_2 + [X]_1 * [gamma]_2 + [C]_1 * [delta]_2
        // e(A, B)
        // e(-X, gamma)
        // e(-C, delta)
        // e(-alpha, beta)
        if (!Pairing.pairingProd4(
                proof.a, proof.b,
                G1.negate(X), vk.gamma,
                G1.negate(proof.c), vk.delta,
                G1.negate(vk.alpha), vk.beta)) return false;

        return true;
    }

    @Callable
    public static boolean verify(BigInteger[] input, byte[] proof) {
        try {
            return verify(input, Proof.deserialize(proof));
        } catch (Exception e) {
            Blockchain.println("verify() failed with exception: " + e.getMessage());
        }

        return false;
    }
}
