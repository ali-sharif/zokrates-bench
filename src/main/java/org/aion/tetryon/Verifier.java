// This file is MIT Licensed
package org.aion.tetryon;

import avm.Blockchain;
import org.aion.avm.tooling.abi.Callable;

import java.math.BigInteger;
import java.util.Arrays;

/**
 * Verifier smart contract. Auto-generated by Zokrates.
 */
@SuppressWarnings({"WeakerAccess", "unused"})
public class Verifier {
    protected static class VerifyingKey {
        public final G1Point alpha;
        public final G2Point beta;
        public final G2Point gamma;
        public final G2Point delta;
        public final G1Point[] gamma_abc;

        public VerifyingKey(G1Point alpha, G2Point beta, G2Point gamma, G2Point delta, G1Point[] gamma_abc) {
            this.alpha = alpha;
            this.beta = beta;
            this.gamma = gamma;
            this.delta = delta;
            this.gamma_abc = gamma_abc;
        }
    }

    protected static class Proof {
        public final G1Point a;
        public final G2Point b;
        public final G1Point c;

        public Proof(G1Point a, G2Point b, G1Point c) {
            this.a = a;
            this.b = b;
            this.c = c;
        }

        // serialized as a | b | c
        public byte[] serialize() {
            byte[] s = new byte[Fp.ELEMENT_SIZE*8];

            byte[] a = G1.serialize(this.a);
            byte[] b = G2.serialize(this.b);
            byte[] c = G1.serialize(this.c);

            System.arraycopy(a, 0, s, 0, a.length);
            System.arraycopy(b, 0, s, 6*Fp.ELEMENT_SIZE - b.length, b.length);
            System.arraycopy(c, 0, s, 8*Fp.ELEMENT_SIZE - c.length, c.length);

            return s;
        }

        public static Proof deserialize(byte[] data) {
            Blockchain.require(data.length == 8*Fp.ELEMENT_SIZE);

            G1Point a = G1.deserialize(Arrays.copyOfRange(data, 0, 2*Fp.ELEMENT_SIZE));
            G2Point b = G2.deserialize(Arrays.copyOfRange(data, 2*Fp.ELEMENT_SIZE, 6*Fp.ELEMENT_SIZE));
            G1Point c = G1.deserialize(Arrays.copyOfRange(data, 6*Fp.ELEMENT_SIZE, 8*Fp.ELEMENT_SIZE));

            return new Proof(a, b, c);
        }
    }

    protected static VerifyingKey verifyingKey() {
        G1Point alpha = new G1Point("1dc8a0ebb4f541c3679cb60d3795dc3cfb097aaff30467d91b9017d206a1d4e4", "06994926e37eb64cb24470350a08ccecdbf1c7478dc546c02851d17424893549");
        G2Point beta = new G2Point("19dab2132678b12735f08a85fd9d3a2b7a184c13f4e43d872fb6478fdb183682", "0b4ef55df16dc49ea2ab766929bea33032f3c11c28b98bba018dcdf94bdb5273", "1ca80bc8441ff9c3699f6606272512f13395a281c8d174a1ca87366bb7c7bb55", "19bfbdd6463abb050fcc66675a13e4cfd5d40003811cb4771966367b86e361a9");
        G2Point gamma = new G2Point("29270a9912f65608c640da9efe9c8e165450dc5765c54efa4d52fc0afec16d38", "28d878253d1fdd503c042ac9b7074867ed113de6413e38957404beb6d2ea204d", "0b6606a2627b5082a0b9842719a09b73e40bc6440f949809dae06b72d9c3a399", "0acccc4f0e11c8c7c96b6248c6b809dbd420c6649e25e55eabb87c3a0691a0ac");
        G2Point delta = new G2Point("0592ce212b555e3c08dc31365c2f7c39f7affa5dd31416bb7aaf0851a4a08af6", "278539b4b78c2a6b3fb7a31aa6c709adee3ed805d0bcfeeb3c53ee7816be60bd", "1f6b23353066c83a6d294380c9ee0683089f3b674c707ae2a76f83f143b4925c", "118d6a29fbadbfb6ff27be349b7b0ea6ffc9367f66ea60c78e566a745b66ca6b");

        G1Point[] gamma_abc = new G1Point[3];
        gamma_abc[0] = new G1Point("0e46ec36856b635e570d75153cd2260c90754aa8118e4f165415a17aed4ba598", "1db67ad265b973c14233d83f1bbb739cbf17cc1d9c01ac13867f182c3687fbec");
        gamma_abc[1] = new G1Point("260cad885d88694caa43d9137074e00f5915cdcd6089476e59fa3f06d9f6889c", "29f2d3f36cba52000d1de4337724ce393462061e07beb54fc7db06b8a40e368f");
        gamma_abc[2] = new G1Point("11e0c137010695df157d9cf737d124dcaf67d606738310840b4a66ff348e4a9a", "07f8bb61f0f8d00e16cabaabaa1c96cfd7d5692ce290fd3c94bc31ad57dfa60d");

        return new VerifyingKey(alpha, beta, gamma, delta, gamma_abc);
    }

    public static boolean verify(BigInteger[] input, Proof proof) throws Exception {
        BigInteger snarkScalarField = new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617");
        VerifyingKey vk = verifyingKey();
        Blockchain.require(input.length + 1 == vk.gamma_abc.length);

        // X = gamma_0 + gamma_1 * input_0 + gamma_2 * input_1
        G1Point X = new G1Point(Fp.zero(), Fp.zero());
        for (int i = 0; i < input.length; i++) {
            Blockchain.require(input[i].compareTo(snarkScalarField) < 0);
            G1Point tmp = G1.mul(vk.gamma_abc[i + 1], input[i]);
            if (i == 0)
                X = tmp;
            else
                X = G1.add(X, tmp);
        }
        X = G1.add(X, vk.gamma_abc[0]);

        // See [Groth16]
        // [A]_1 * [B]_2 = [alpha]_1 * [beta]_2 + [X]_1 * [gamma]_2 + [C]_1 * [delta]_2
        // e(A, B)
        // e(-X, gamma)
        // e(-C, delta)
        // e(-alpha, beta)
        if (!Pairing.pairingProd4(
                proof.a, proof.b,
                G1.negate(X), vk.gamma,
                G1.negate(proof.c), vk.delta,
                G1.negate(vk.alpha), vk.beta)) return false;

        return true;
    }

    @Callable
    public static boolean verify(BigInteger[] input, byte[] proof) {
        Blockchain.println("verify called!");
        try {
            return verify(input, Proof.deserialize(proof));
        } catch (Exception e) {
            Blockchain.println("verify() failed with exception: " + e.getMessage());
        }

        return false;
    }
}
